{% extends "base.html.twig" %}

{% block title %}Report{% endblock %}

{% block main %}
    <h1>Redovisningar:</h1>

    <ul>
        <li><a href="#kmom01">Kmom01</a></li>
        <li><a href="#kmom02">Kmom02</a></li>
        <!-- Add more kmom links as needed -->
    </ul>

    <h2 id="kmom01">Kmom01</h2>
    <p>Jag har tidigare erfarenhet av att arbeta med objektorienterad programmering, genom min tidigare kurs i Python. Där lärde jag mig hur man strukturerar kod genom att definiera klasser och använda objekt för att organisera och återanvända kod. Objektorientering möjliggör en mer modulär och strukturerad kodbas genom att tillåta oss att gruppera relaterade data och funktioner inom enskilda enheter kallade klasser. Detta ger ökad flexibilitet, underhållbarhet och återanvändbarhet av kod.</p><br>
    <p>PHPs modell för klasser och objekt fungerar nästan på samma sätt som i Python, med skillnaden att det är ett annat programmeringsspråk. I PHP är en klass en mall för att skapa objekt. En klass kan innehålla egenskaper (attribut) och metoder (funktioner). Att skapa en instans av en klass innebär att skapa ett objekt baserat på den klassen. En konstruktor är en speciell metod som används för att initialisera objekt av en klass genom att tilldela värden till objektets attribut.</p><br>
    <p>Strukturen som användes i uppgiften me/report är baserad på en huvudklass kallad PresentationController som ärver från AbstractController-klassen. Detta möjliggör att PresentationController kan använda attribut och metoder som är definierade i AbstractController. I koden finns det olika metoder som är definierade i PresentationController, såsom presentation, about, report och lucky. Varje metod representerar en specifik webbrutt för applikationen. Dessa metoder svarar på HTTP-förfrågningar på olika URL-rutter (/, /about, /report, /lucky) och returnerar en Response-objekt som innehåller den resulterande sidan. Varje metod använder också Twig-mallar för att rendera HTML-sidorna som ska visas för användaren. </p>
    <p>Jag fann både begreppet namespace och användningen av magiska metoder intressanta och värdefulla aspekter i artikeln "PHP The Right Way".
        Namespace-konceptet erbjuder en strukturerad metod för att organisera PHP-kod, vilket hjälper till att undvika namnkollisioner och göra koden mer läsbar och underhållbar. Genom att gruppera relaterade klasser och funktioner inom samma namespace blir det lättare att hantera och navigera i koden, vilket är särskilt användbart i större projekt.
        De magiska metoderna är också fascinerande eftersom de tillåter utvecklare att skapa mer dynamiska och flexibla klasser. Till exempel kan användningen av __construct()-metoden för att initiera objekt och __get() samt __set()-metoderna för att hantera egenskaper göra koden mer elegant och mindre repetitiv. Dessutom kan __toString()-metoden användas för att definiera hur objekt ska representeras som strängar, vilket kan vara användbart vid debugging och loggning.</p>
    <p> Min TiL för detta kursmomentet är Att arbeta med klasser i PHP ger en grundläggande förståelse för objektorienterad programmering och hur man strukturerar kod på ett mer organiserat sätt. Dessutom är det att skapa olika rutter med Twig och Symfony Framework ett värdefullt steg för att bygga webbapplikationer och hantera klientbegäranden på ett effektivt sätt.</p>

    <h2 id="kmom02">Kmom02</h2>

    <p>I objektorienterad programmering finns det olika konstruktioner för att organisera och strukturera klasser:</p>
    <p>Arv (Inheritance):
    Arv innebär att en klass (barnklass) kan ärva egenskaper och metoder från en annan klass (förälderklass). I PHP uppnås detta genom att använda nyckelordet extends.</p> 
 
    <p>Komposition (Composition):
    Komposition innebär att en klass använder en instans av en annan klass som en av sina medlemmar. Detta ger flexibilitet genom att tillåta konstruktion av komplexa objekt genom att kombinera mindre komponenter. I PHP skapas komposition genom att skapa instanser av andra klasser inuti den aktuella klassen.</p>

    <p>Jag löste uppgiften genom att skapa fyra huvudklasser: Card, CardGraphic, DeckOfCards, och en controller-klass för spelet. Varje klass hade sin specifika uppgift och samverkade för att hantera kortspel.

Card representerade en enskild spelkort och innehöll information om dess svit och värde, samt en metod för att få dess strängrepresentation.

CardGraphic var en underklass av Card som utökade funktionaliteten genom att lägga till grafisk representation för varje kort, med hjälp av emojis för att representera kortets svit och värde.

DeckOfCards representerade en hel kortlek och skapade en ny kortlek med alla fyra sviterna och 13 värden (från 1 till 13). Den innehöll också metoder för att hantera kortleken som att hämta, sortera, blanda och dra kort från leken.

Jag är generellt nöjd med min implementation eftersom den uppfyller kraven för att hantera ett kortspel.</p>
{% endblock %}
